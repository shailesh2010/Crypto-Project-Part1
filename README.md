# Crypto-Project-Part1

Introduction: 
The problem was to obtain the plaintext from the given ciphertext in a reasonable amount of time with partial knowledge of the encryption scheme used. The key is unknown and polyalphabetic substitution ciphers were used. However, two dictionaries were given as input such that the possible plaintext was only one out of those. This information proved to be vital for cryptanalysis of the cipher text.
This attack may come under the recognized domain of known-plaintext attacks. It is, because, we have a set of plaintexts such that the actual plaintext is one of them. We have also conducted a brief survey on substitution ciphers.


Description of Approach: 

Input:
1)Key length between 1 and 18
2)L character long cipher text which consist of only {<space>,a-z} (L is most likely 100)


Output:
Possible Plain text

Basic Approach:
Our basic approach was to make use of every possible that was mentioned in the project description. To start with, we know the encryption scheme partially, we knew cipher and plaintext length and most importantly we knew the size of the key. Since we already knew the plaintext, we tried to create possible key sets and through elimination, we were able to track down the possible plaintext for the given cipher. This technique is common to method that we implemented to crack cipher for plaintext from dictionary 1 and 2.


Approach for Dictionary 1:
For every plaintext in dictionary 1, we created a key set for the selected plaintext and cipher by finding the position shift between the plaintext and the cipher. We also accounted for the adding of the previous cipher value at the time of encryption.
Once we had the key set for a plaintext, we generated a unique set from the calculated key set. If the size of the unique set is greater than t, then it is clear that the cipher is not for the plaintext corresponding to the key set because number of unique key set elements canâ€™t be more that t in any case.
This strategy worked well for us as we were able to eliminate most of the candidate plaintexts. Since Dictionary 1 is a small set, we expect this strategy to work for various key lengths. To cross check our claims, we created our own encryption program and generated test ciphers using various key lengths and j(i) function variations.



Approach for Dictionary 2:
This was a bit tougher nut to crack. Since the plaintext was generated by selecting words randomly, we could not use the technique used for Dictionary 1 directly as there are 100 ^ 100 possible combinations possible and it is definitely in feasible to generate such combinations and crack the cipher in a reasonable amount of time.
To deal with this, we devised a strategy of starting small. We first created all possible 3-word combinations for the words in dictionary Then, as we did in case of dictionary 1, we calculated unique key sets for each of the combinations. We eliminated combinations where the unique key set size was greater than t. We then created all possible 4 word combinations and applied key set technique again.
We repeated the above steps till the length of the word combinations was less than equal to 100 and also we created a final list of possible plaintexts. We removed all the duplicates and showed all the possible plaintexts.
